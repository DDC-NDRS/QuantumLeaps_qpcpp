//$file${include::qk.hpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${include::qk.hpp}
//
// This code has been generated by QM 5.2.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2023-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${include::qk.hpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//! @date Last updated on: 2022-06-30
//! @version Last updated for: @ref qpcpp_7_0_1
//!
//! @file
//! @brief QK/C++ platform-independent public interface.

#ifndef QK_HPP
#define QK_HPP

#include "qequeue.hpp" // QK kernel uses the native QF event queue
#include "qmpool.hpp"  // QK kernel uses the native QF memory pool

//============================================================================
// QF configuration for QK -- data members of the QActive class...

// QK event-queue used for AOs
#define QF_EQUEUE_TYPE  QEQueue

// QK thread type used for AOs
// QK uses this member to store the private Thread-Local Storage pointer.
//
#define QF_THREAD_TYPE  void*

//============================================================================
namespace QP {
    class QActive; // forward declaration
} // namespace QP

extern "C" {
//$declare${QK-extern-C} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${QK-extern-C::QK_Attr} ....................................................
//! attributes of the QK kernel (extern "C" for easy access in assembly)
class QK_Attr {
public:

    //! prio of the active AO
    std::uint8_t volatile actPrio;

    //! prio of the next AO to execute
    std::uint8_t volatile nextPrio;

    //! lock prio (0 == no-lock)
    std::uint8_t volatile lockPrio;

    //! prio of the lock holder
    std::uint8_t volatile lockHolder;
}; // class QK_Attr

//${QK-extern-C::QK_attr_} ...................................................
//! attributes of the QK kernel (extern "C" to be accessible from C)
extern QK_Attr QK_attr_;

//${QK-extern-C::QK_sched_} ..................................................
//! QK scheduler finds the highest-priority thread ready to run
//!
//! @description
//! The QK scheduler finds out the priority of the highest-priority AO
//! that (1) has events to process and (2) has priority that is above the
//! current priority.
//!
//! @returns the 1-based priority of the the active object, or zero if
//! no eligible active object is ready to run.
//!
//! @attention
//! QK_sched_() must be always called with interrupts **disabled** and
//! returns with interrupts **disabled**.
//!
std::uint_fast8_t QK_sched_() noexcept;

//${QK-extern-C::QK_activate_} ...............................................
//! QK activator activates the next active object. The activated AO preempts
//! the currently executing AOs
//!
//! @description
//! QK_activate_() activates ready-to run AOs that are above the initial
//! active priority (QK_attr_.actPrio).
//!
//! @note
//! The activator might enable interrupts internally, but always returns with
//! interrupts **disabled**.
//!
void QK_activate_() noexcept;

//${QK-extern-C::QK_onContextSw} .............................................
#ifdef QK_ON_CONTEXT_SW
//! QK context switch callback (customized in BSPs for QK)
//!
//! @description
//! This callback function provides a mechanism to perform additional
//! custom operations when QK switches context from one thread to
//! another.
//!
//! @param[in] prev   pointer to the previous thread (active object)
//!                   (prev==0 means that @p prev was the QK idle loop)
//! @param[in] next   pointer to the next thread (active object)
//!                   (next==0) means that @p next is the QK idle loop)
//! @attention
//! QK_onContextSw() is invoked with interrupts **disabled** and must also
//! return with interrupts **disabled**.
//!
//! @note
//! This callback is enabled by defining the macro #QK_ON_CONTEXT_SW.
//!
//! @include qk_oncontextsw.cpp
//!
void QK_onContextSw(
    QP::QActive * prev,
    QP::QActive * next) ;
#endif // def QK_ON_CONTEXT_SW
//$enddecl${QK-extern-C} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
} // extern "C"

//============================================================================
//$declare${QK::QSchedStatus} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {

//${QK::QSchedStatus} ........................................................
//! The QK scheduler lock status
using QSchedStatus  = std::uint_fast16_t;

} // namespace QP
//$enddecl${QK::QSchedStatus} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$declare${QK::QK} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {
namespace QK {

//${QK::QK::onIdle} ..........................................................
//! QK idle callback (customized in BSPs for QK)
//!
//! @description
//! QK::onIdle() is called continously by the QK idle loop. This callback
//! gives the application an opportunity to enter a power-saving CPU mode,
//! or perform some other idle processing.
//!
//! @note
//! QK::onIdle() is invoked with interrupts enabled and must also return
//! with interrupts enabled.
//!
//! @sa QV::onIdle(), QXK::onIdle()
void onIdle() ;

//${QK::QK::schedLock} .......................................................
//! QK selective scheduler lock
//!
//! @description
//! This function locks the QK scheduler to the specified ceiling.
//!
//! @param[in]   ceiling    priority ceiling to which the QK scheduler
//!                         needs to be locked
//!
//! @returns
//! The previous QK Scheduler lock status, which is to be used to unlock
//! the scheduler by restoring its previous lock status in
//! QP::QK::schedUnlock().
//!
//! @note
//! QP::QK::schedLock() must be always followed by the corresponding
//! QP::QK::schedUnlock().
//!
//! @sa QK_schedUnlock()
//!
//! @usage
//! The following example shows how to lock and unlock the QK scheduler:
//! @include qk_lock.cpp
//!
QSchedStatus schedLock(std::uint_fast8_t const ceiling) noexcept;

//${QK::QK::schedUnlock} .....................................................
//! QK selective scheduler unlock
//!
//! @description
//! This function unlocks the QK scheduler to the previous status.
//!
//! @param[in]   stat       previous QK Scheduler lock status returned from
//!                         QP::QK::schedLock()
//! @note
//! QP::QK::schedUnlock() must always follow the corresponding
//! QP::QK::schedLock().
//!
//! @sa QP::QK::schedLock()
//!
//! @usage
//! The following example shows how to lock and unlock the QK scheduler:
//! @include qk_lock.cpp
//!
void schedUnlock(QSchedStatus const stat) noexcept;

} // namespace QK
} // namespace QP
//$enddecl${QK::QK} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//============================================================================
// interface used only inside QF, but not in applications

#ifdef QP_IMPL

    #ifndef QK_ISR_CONTEXT_
        //! Internal port-specific macro that reports the execution context
        // (ISR vs. thread).
        //! @returns true if the code executes in the ISR context and false
        //! otherwise
        #define QK_ISR_CONTEXT_()  (QF_intNest_ != 0U)
    #endif // QK_ISR_CONTEXT_

    // QK-specific scheduler locking
    //! Internal macro to represent the scheduler lock status
    //! that needs to be preserved to allow nesting of locks.
    //!
    #define QF_SCHED_STAT_ QSchedStatus lockStat_;

    //! Internal macro for selective scheduler locking.
    #define QF_SCHED_LOCK_(prio_) do {          \
        if (QK_ISR_CONTEXT_()) {                \
            lockStat_ = 0xFFU;                  \
        } else {                                \
            lockStat_ = QK::schedLock((prio_)); \
        }                                       \
    } while (false)

    //! Internal macro for selective scheduler unlocking.
    #define QF_SCHED_UNLOCK_() do {     \
        if (lockStat_ != 0xFFU) {       \
            QK::schedUnlock(lockStat_); \
        }                               \
    } while (false)

    // QK-specific native event queue operations...
    #define QACTIVE_EQUEUE_WAIT_(me_) \
        Q_ASSERT_ID(110, (me_)->m_eQueue.m_frontEvt != nullptr)

    #define QACTIVE_EQUEUE_SIGNAL_(me_) do {                \
        QF::readySet_.insert(                               \
            static_cast<std::uint_fast8_t>((me_)->m_prio)); \
        if (!QK_ISR_CONTEXT_()) {                           \
            if (QK_sched_() != 0U) {                        \
                QK_activate_();                             \
            }                                               \
        }                                                   \
    } while (false)

    // QK-specific native QF event pool operations...
    #define QF_EPOOL_TYPE_  QMPool
    #define QF_EPOOL_INIT_(p_, poolSto_, poolSize_, evtSize_) \
        (p_).init((poolSto_), (poolSize_), (evtSize_))
    #define QF_EPOOL_EVENT_SIZE_(p_)  ((p_).getBlockSize())
    #define QF_EPOOL_GET_(p_, e_, m_, qs_id_) \
        ((e_) = static_cast<QEvt *>((p_).get((m_), (qs_id_))))
    #define QF_EPOOL_PUT_(p_, e_, qs_id_) ((p_).put((e_), (qs_id_)))

#endif // QP_IMPL

#endif // QK_HPP
